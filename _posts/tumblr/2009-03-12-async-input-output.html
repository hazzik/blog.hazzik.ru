---
layout: post
title: Асинхронный ввод-вывод. Проблемы
date: '2009-03-12T17:09:00+13:00'
tags:
- Асинхронный ввод-вывод
- network
- Sockets
- .NET
tumblr_url: http://blog.hazzik.ru/post/19465314482
redirect_from:
- /post/19465314482/
---
<p><span></span><span style="font-weight: bold;">Проблема</span>: допустим вы пишете простой -сервер, который получает какое-то сообщение от клиента, обрабатывает его и что-то ему отправляет. Протокол вы разрабатываете сами, на основе TCP/IP. Встает вопрос что выбрать: синхронные или асинхронные сокеты. Рассмотрим каждый вариант подробнее.<a name="more"></a><br/><br/>Типичная диаграмма последовательности для решаемой задачи<br/><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_VEYwyqMSqYM/SbkYU39RC8I/AAAAAAAAAEA/mOfKuhZLlAY/s1600-h/seq.png"><img style="margin: 0pt 10px 10px 0pt; float: left; cursor: pointer; width: 161px; height: 320px;" src="http://4.bp.blogspot.com/_VEYwyqMSqYM/SbkYU39RC8I/AAAAAAAAAEA/mOfKuhZLlAY/s320/seq.png" alt="" id="BLOGGER_PHOTO_ID_5312303982357580738" border="0"/></a><br/></p><h4>Синхронные сокеты.</h4>При работе с синхронными сокетами, при вызове какой-либо операции текущий поток выполнения блокируется, до завершения операции. Ну ничего, решаете вы и выделяете по потоку на каждое соединение (или по два, если нужна независимая отправка). Пока ваше приложение  маленькое, и пользуются им относительно небольшое количество одновременных пользователей, вы счастливы. Но как только количество пользователей переходит какой-то критический барьер - приложение начинает жутко тормозить. Давайте разберемся почему?<br/><br/><ol><li>На каждый поток операционной системой выделяется определенный минимальный объем оперативной памяти (для стека и пр. - около 1 мб), при 500 пользователях это будет 500 МБ, без учета памяти потребляемой клиентом на выполнение своих операций.</li><li>Переключение между потоками выполнения занимает какое-то время.</li><li>Большинство потоков &#8220;висит&#8221; в ожидании завершения синхронной операции, при этом время на переключение между потоками продолжает тратиться.</li><li>Трудность отладки многопоточных приложений.<br/></li></ol>Для решения этих и других проблем синхронного ввода-вывода и придумали асинхронные вызовы.<br/><br/><h4>Асинхронные сокеты</h4>Для решения проблем выше были придуманы асинхронные сокеты и операции. При вызове асинхронной операции - поток выполнения не блокируется, а продолжает свое выполнение. В большинстве случаев асинхронные вызовы работают через так называемые порты завершения (<span style="font-style: italic;">IOCP</span>). При вызове асинхронной операции сокет ассоциируется с каким-либо портом завершения, сокет будет оповещать этот поток о намерениях завершить операцию. При сигнале от сокета, порт берет из пула потоков (<span style="font-style: italic;">thread pool</span>), свободный поток и завершает операцию (в зависимости от реализации может потребоваться вызвать метод завершения операции).<br/>Что мы от этого выигрываем? Нет потоков ожидающих завершения операции, а следовательно потраченого впустую процессорного времени на переключение между ними; минимальное количество потоков; другие плюшки:)<br/><h5>Проблемы</h5>При любом чтении или записи из сокета возвращается МЕНЬШЕЕ или равное ожидаемому количество байт. И если при работе с синхронными сокетами мы могли быть уверены, что получим сообщение полностью, написав цикл, который будет вычитывать строго необходимое количество данных в буфер (также для отправки, включая асинхронную). При асинхронном получении данных такой уверенности нет (при условии, что длина не фиксирована) - приложение просто выплюнет нам какой-то обрывок сообщения, или два, или полтора - как получиться. Таким образом необходимо будет потратить какое-то время на разбор приходящих сообщений.<br/>Вторая проблема - т.к. асинхронные сокеты работают через нативный <span style="font-style: italic;">IOCP</span>, то буферы для приема и отправки будут в состоянии <span style="font-style: italic;">pined</span>. А множество пришпиленых объектов - зло, т.к. будет способствовать фрагментации кучи (подробнее <a href="https://blogs.msdn.com/yunjin/archive/2004/01/27/63642.aspx">тут</a>), поэтому обычно принимается решение выделить один большой буфер, и использовать его постоянно. В .NET 2.0 появилась возможность вместе с асинхронными сокетами использовать <a href="http://msdn.microsoft.com/ru-ru/library/1hsbd92d.aspx">ArraySegment{T}</a>, который может &#8220;разбить&#8221; наш большой буфер на несколько небольших сегментов, но не все так просто, как кажеться - всем этим хозяйством необходимо управлять. Итого нам необходим менеджер сегментов (можно почитать <a href="http://codebetter.com/blogs/gregyoung/archive/2007/06/18/async-sockets-and-buffer-management.aspx">тут</a>), и парсер сообщений.<div class="blogger-post-footer"><img width="1" height="1" src="https://blogger.googleusercontent.com/tracker/1624027437398699573-3455392215667477468?l=hazzik.blogspot.com" alt=""/></div>
